# src/railway_simulator/core/report.py

from __future__ import annotations

from pathlib import Path
from typing import Dict, Any

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from matplotlib.backends.backend_pdf import PdfPages


def _add_footer(fig, text: str) -> None:
    fig.text(0.5, 0.02, text, ha="center", va="bottom", fontsize=8)


def generate_single_run_report(
    results: pd.DataFrame,
    perf: Dict[str, Any],
    params: Dict[str, Any],
    pdf_path: Path,
) -> None:
    """
    Generate a compact single-run PDF report with:
      - text summary (config + performance)
      - force & penetration vs time
      - energy components (if available)
    """
    pdf_path = Path(pdf_path)
    pdf_path.parent.mkdir(parents=True, exist_ok=True)

    with PdfPages(pdf_path) as pdf:
        # --------------------------------------------------------------
        # Page 1: Summary (config + performance)
        # --------------------------------------------------------------
        fig, ax = plt.subplots(figsize=(8.27, 11.69))  # A4 portrait
        ax.axis("off")

        v0 = float(params.get("v0_init", 0.0))
        v_kmh = -v0 * 3.6
        n_masses = int(params.get("n_masses", len(params.get("masses", []))))
        contact_model = params.get("contact_model", "unknown")
        k_wall = float(params.get("k_wall", 0.0)) / 1e6  # MN/m
        cr_wall = float(params.get("cr_wall", 0.0))

        lines = [
            "Railway Impact Simulator – Single Run Report",
            "",
            f"Initial speed           : {v_kmh:.1f} km/h",
            f"Number of mass points   : {n_masses}",
            f"Contact model           : {contact_model}",
            f"Wall stiffness          : {k_wall:.3f} MN/m",
            f"Restitution coefficient : {cr_wall:.3f}",
            "",
            "Performance:",
        ]

        def add_perf(label: str, key: str, fmt: str = ".3f", unit: str = ""):
            if key in perf and perf[key] is not None:
                val = perf[key]
                if isinstance(val, int):
                    s = f"{val:d}"
                else:
                    s = f"{val:{fmt}}"
                lines.append(
                    f"  {label:<24}: {s}{(' ' + unit) if unit else ''}"
                )

        add_perf("Wall-clock time", "wall_time", ".3f", "s")
        add_perf("Simulated time span", "T_max", ".6f", "s")
        add_perf("Time steps", "steps")
        add_perf("Mean Δt", "dt_mean", ".6e", "s")
        add_perf("Min Δt", "dt_min", ".6e", "s")
        add_perf("Max Δt", "dt_max", ".6e", "s")
        add_perf("Real-time factor", "real_time_factor", ".2f", "x")
        add_perf("Linear solves (LU)", "linear_solves")
        add_perf("n_dof", "n_dof")
        add_perf("Estimated FLOPs (LU)", "mflops", ".2f", "MFLOP")
        add_perf("Estimated rate", "mflops_per_s", ".2f", "MFLOP/s")

        text = "\n".join(lines)
        ax.text(0.05, 0.95, text, va="top", ha="left", fontsize=10)
        _add_footer(fig, "Generated by railway-impact-simulator")
        pdf.savefig(fig)
        plt.close(fig)

        # --------------------------------------------------------------
        # Page 2: Force & penetration vs time
        # --------------------------------------------------------------
        time_ms = results["Time_ms"].to_numpy()
        F = results["Impact_Force_MN"].to_numpy()
        u = results["Penetration_mm"].to_numpy()

        fig, ax1 = plt.subplots(figsize=(8.27, 5.5))
        ax1.set_title("Impact force and penetration vs time")
        ax1.plot(time_ms, F, label="Impact force")
        ax1.set_xlabel("Time [ms]")
        ax1.set_ylabel("Impact force [MN]")
        ax1.grid(True)

        ax2 = ax1.twinx()
        ax2.plot(time_ms, u, linestyle="--", label="Penetration")
        ax2.set_ylabel("Penetration [mm]")

        lines1, labels1 = ax1.get_legend_handles_labels()
        lines2, labels2 = ax2.get_legend_handles_labels()
        ax1.legend(lines1 + lines2, labels1 + labels2, loc="upper right")

        _add_footer(fig, "Force and penetration histories")
        pdf.savefig(fig)
        plt.close(fig)

        # --------------------------------------------------------------
        # Page 3: Energies (if present)
        # --------------------------------------------------------------
        energy_cols = [c for c in results.columns if c.endswith("_J")]

        if energy_cols:
            fig, ax = plt.subplots(figsize=(8.27, 5.5))
            ax.set_title("Energy components vs time")
            for col in energy_cols:
                ax.plot(results["Time_ms"], results[col], label=col)
            ax.set_xlabel("Time [ms]")
            ax.set_ylabel("Energy [J]")
            ax.grid(True)
            ax.legend(fontsize=7)
            _add_footer(fig, "Energy bookkeeping")
            pdf.savefig(fig)
            plt.close(fig)


def generate_parametric_report(
    envelope: pd.DataFrame,
    summary: pd.DataFrame,
    perf: Dict[str, Any],
    quantity: str,
    pdf_path: Path,
) -> None:
    """
    Generate a parametric-study PDF report with:
      - summary (performance + quantity)
      - envelope plot
      - compact table of scenario summary
    """
    pdf_path = Path(pdf_path)
    pdf_path.parent.mkdir(parents=True, exist_ok=True)

    with PdfPages(pdf_path) as pdf:
        # --------------------------------------------------------------
        # Page 1: Summary
        # --------------------------------------------------------------
        fig, ax = plt.subplots(figsize=(8.27, 11.69))
        ax.axis("off")

        lines = [
            "Railway Impact Simulator – Parametric Study Report",
            "",
            f"Enveloped quantity: {quantity}",
            "",
            "Performance:",
        ]

        def add_perf(label: str, key: str, fmt: str = ".3f", unit: str = ""):
            if key in perf and perf[key] is not None:
                val = perf[key]
                if isinstance(val, int):
                    s = f"{val:d}"
                else:
                    s = f"{val:{fmt}}"
                lines.append(
                    f"  {label:<24}: {s}{(' ' + unit) if unit else ''}"
                )

        add_perf("Wall-clock time", "wall_time", ".3f", "s")
        add_perf("Simulated time span", "T_max", ".6f", "s")
        add_perf("Time steps", "steps")
        add_perf("Mean Δt", "dt_mean", ".6e", "s")
        add_perf("Min Δt", "dt_min", ".6e", "s")
        add_perf("Max Δt", "dt_max", ".6e", "s")
        add_perf("Real-time factor", "real_time_factor", ".2f", "x")
        add_perf("Linear solves (LU)", "linear_solves")
        add_perf("n_dof", "n_dof")
        add_perf("Estimated FLOPs (LU)", "mflops", ".2f", "MFLOP")
        add_perf("Estimated rate", "mflops_per_s", ".2f", "MFLOP/s")

        text = "\n".join(lines)
        ax.text(0.05, 0.95, text, va="top", ha="left", fontsize=10)
        _add_footer(fig, "Generated by railway-impact-simulator")
        pdf.savefig(fig)
        plt.close(fig)

        # --------------------------------------------------------------
        # Page 2: Envelope plot
        # --------------------------------------------------------------
        time_col = "Time_ms" if "Time_ms" in envelope.columns else "Time_s"
        t = envelope[time_col].to_numpy()

        # Resolve correct column, e.g. "Impact_Force_MN_envelope"
        if quantity in envelope.columns:
            y_col = quantity
        else:
            env_col = f"{quantity}_envelope"
            if env_col in envelope.columns:
                y_col = env_col
            else:
                non_time_cols = [
                    c for c in envelope.columns
                    if c not in ("Time_s", "Time_ms")
                ]
                if not non_time_cols:
                    raise RuntimeError(
                        f"Could not find column for quantity '{quantity}' in envelope."
                    )
                y_col = non_time_cols[0]

        y = envelope[y_col].to_numpy()

        fig, ax = plt.subplots(figsize=(8.27, 5.5))
        ax.set_title(f"Envelope of {y_col} vs time")
        ax.plot(t, y, label=f"Envelope {y_col}")
        ax.set_xlabel(f"{time_col.replace('_', ' ')}")
        ax.set_ylabel(y_col)

        ax.grid(True)
        ax.set_xlim(left=0)
        ax.set_ylim(bottom=0)
        ax.legend()
        _add_footer(fig, "Parametric envelope")
        pdf.savefig(fig)
        plt.close(fig)

        # --------------------------------------------------------------
        # Page 3: Scenario summary table (first 10 rows)
        # --------------------------------------------------------------
        if not summary.empty:
            fig, ax = plt.subplots(figsize=(8.27, 5.5))
            ax.axis("off")
            cols = list(summary.columns)
            head = summary.head(10)

            table_lines = []
            header_line = " | ".join(cols)
            table_lines.append(header_line)
            table_lines.append("-" * len(header_line))

            for _, row in head.iterrows():
                values = [str(row[c]) for c in cols]
                table_lines.append(" | ".join(values))

            text = "Scenario summary (first 10 rows):\n\n" + "\n".join(table_lines)
            ax.text(0.05, 0.95, text, va="top", ha="left", fontsize=8)
            _add_footer(fig, "Scenario summary")
            pdf.savefig(fig)
            plt.close(fig)
